#ifdef USE_NEW_MODEM_IF

#include <array>
#include <memory>
#include <string>
#include <utility>

#include "modem_if.h"

#include "modem-sniffer.h"
#include "fnSystem.h"
#include "fnConfig.h"
#include "fnWiFi.h"
// #include "siocpm.h"
// #include "led.h"
#include "utils.h"

#include "../../include/debug.h"

// TODO: if this needs to be different per device, it will need reworking into something
// generated by the subclasses
static const telnet_telopt_t telopts[] = {
    {TELNET_TELOPT_ECHO, TELNET_WONT, TELNET_DO},
    {TELNET_TELOPT_TTYPE, TELNET_WILL, TELNET_DONT},
    {TELNET_TELOPT_COMPRESS2, TELNET_WONT, TELNET_DO},
    {TELNET_TELOPT_MSSP, TELNET_WONT, TELNET_DO},
    {-1, 0, 0}
};

modem_if::modem_if(std::unique_ptr<TelnetEventHandler> handler, std::unique_ptr<ModemSniffer> sniffer) : 
    telnet_event_handler(std::move(handler)), telnet(nullptr, TelnetDeleter()), modem_sniffer(std::move(sniffer)) {

    tcp_server = std::make_unique<fnTcpServer>();

    command_handlers = {
        {"AT",             [this]() { handle_at(); }},
        {"ATNET0",         [this]() { handle_net(false); }},
        {"ATNET1",         [this]() { handle_net(true); }},
        {"ATA",            [this]() { handle_answer(); }},
        {"ATIP",           [this]() { handle_set_ip(); }},
        {"AT?",            [this]() { handle_help(); }},
        {"ATH",            [this]() { handle_hangup(); }},
        {"+++ATH",         [this]() { handle_hangup(); }},
        {"ATDT",           [this]() { handle_dial(); }},
        {"ATDP",           [this]() { handle_dial(); }},
        {"ATDI",           [this]() { handle_dial(); }},
        {"ATWIFILIST",     [this]() { handle_wifi_list(); }},
        {"ATWIFICONNECT",  [this]() { handle_wifi_connect(); }},
        {"ATGET",          [this]() { handle_get(); }},
        {"ATPORT",         [this]() { handle_port(); }},
        {"ATV0",           [this]() { handle_v0(); }},
        {"ATV1",           [this]() { handle_v1(); }},
        {"ATE0",           [this]() { handle_e(false); }},
        {"ATE1",           [this]() { handle_e(true); }},
        {"ATH2",           [this]() { handle_hangup(); }},
        {"ATS0=0",         [this]() { handle_s0(false); }},
        {"ATS0=1",         [this]() { handle_s0(true); }},
        {"AT+SNIFF",       [this]() { handle_sniff(true); }},
        {"AT-SNIFF",       [this]() { handle_sniff(false); }},
        {"AT+TERM=VT52",   [this]() { handle_term("VT52"); }},
        {"AT+TERM=VT100",  [this]() { handle_term("VT100"); }},
        {"AT+TERM=ANSI",   [this]() { handle_term("ANSI"); }},
        {"AT+TERM=DUMB",   [this]() { handle_term("DUMB"); }},
        {"ATCPM",          [this]() { handle_cpm(); }},
        {"ATPBLIST",       [this]() { handle_pb_list(); }},
        {"ATPBCLEAR",      [this]() { handle_pb_clear(); }},
        {"ATPB",           [this]() { handle_pb(); }},
        {"ATO",            [this]() { handle_o(); }},

        {"AT&F",           [this]() { handle_ignored(); }},
        {"ATS2=43",        [this]() { handle_ignored(); }},
        {"ATS5=8",         [this]() { handle_ignored(); }},
        {"ATS6=2",         [this]() { handle_ignored(); }},
        {"ATS7=30",        [this]() { handle_ignored(); }},
        {"ATS12=20",       [this]() { handle_ignored(); }},
        {"ATM0",           [this]() { handle_ignored(); }},
        {"ATM1",           [this]() { handle_ignored(); }},
        {"ATX1",           [this]() { handle_ignored(); }},
        {"AT&C1",          [this]() { handle_ignored(); }},
        {"AT&D2",          [this]() { handle_ignored(); }},
        {"AT&W",           [this]() { handle_ignored(); }},
        {"+++ATZ",         [this]() { handle_ignored(); }},
        {"ATS2=128 X1 M0", [this]() { handle_ignored(); }}

    };
}

modem_if::~modem_if() {
    if (telnet) {
        telnet_free(telnet.get());
    }

    if (tcp_client) {
        tcp_client->stop();
    }
    if (tcp_server) {
        tcp_server->stop();
    }
}

void modem_if::handle_ignored() {
    send_response(RESULT_CODE_OK);
}

void modem_if::telnet_event_handler_fn(telnet_t *telnet, telnet_event_t *ev, void *user_data) {
    auto* modem_ = static_cast<modem_if*>(user_data);
    modem_->telnet_event_handler->handle_event(telnet, ev, user_data);
}

void modem_if::send_response(ResultCode code) {
    if (use_numeric_result_code) {
        at_cmd_resultCode(code);
    } else {
        auto message_it = result_code_messages.find(code);
        if (message_it != result_code_messages.end()) {
            at_cmd_println(message_it->second);
        } else {
            at_cmd_println("ERROR: UNKNOWN CODE: ", false);
            at_cmd_println(code);
        }
    }
}

void modem_if::modem_command() {
    // TODO: test carefully non of the AT commands expect the EOL char that we are removing here.
    util_up_to_eol(cmd);
    util_string_trim(cmd);
    if (cmd.empty()) return;

    std::string upper_case_cmd = cmd;

    util_string_toupper(upper_case_cmd);
    // I think the original intent of at_cmd_println() was to echo the cmd itself, with a ln(), but all it now does is print a ln();
    // in the original code, "cmd" is not passed into the function, so it would just print an empty string. TODO: test how this affects things.
    if (command_echo) at_cmd_println(cmd);

    auto handler_it = command_handlers.find(upper_case_cmd);
    if (handler_it != command_handlers.end()) {
        Debug_printf("AT Cmd: %s\n", upper_case_cmd.c_str());
        handler_it->second();
    } else {
        Debug_printf("Unhandled AT cmd: %s\n", upper_case_cmd.c_str());
    }
}

void modem_if::handle_at() {
    send_response(RESULT_CODE_OK);
}

void modem_if::handle_net(bool _use_telnet) {
    use_telnet = _use_telnet;
    send_response(RESULT_CODE_OK);
}

void modem_if::handle_answer() {
    Debug_printf("HANDLE ANSWER\n");
    if (tcp_server->hasClient()) {
        tcp_client = tcp_server->available_ptr();
        tcp_client->setNoDelay(true); // try to disable naggle
        answer_timer = fnSystem.millis();
        answered = false;
        CRX = true;

        cmd_mode = false;
        get_uart()->flush();
        answer_hack = false;
    }
}

void modem_if::handle_set_ip() {
    if (fnWiFi.connected()) {
        at_cmd_println(fnSystem.Net.get_ip4_address_str());
    }
    else {
        send_help_message(HELPNOWIFI);
    }
    send_response(RESULT_CODE_OK);
}

auto helpMessages = std::to_array({
// const std::array<std::string, 26> modem_if::helpMessages = {
    "       FujiNet Virtual Modem",
    "=======================================",
    "",
    "ATWIFILIST        | List avail networks",
    "ATWIFICONNECT<ssid>,<key>   Set up WiFi",
    "ATH               | Hangup",
    "ATDT<host>:<port> | Connect by TCP",
    "ATIP              | See my IP address",
    "ATNET<0|1>        | Dis/enable TELNET",
    "                  | command handling",
    "ATPORT<port>      | Set listening port",
    "ATE<0|1>          | Echo OFF/ON",
    "AT                | Returns OK",
    "ATGET<URL>        | HTTP GET",
    "AT+TERM=<termtype>| Set telnet term",
    "                  | type (DUMB, VT52,",
    "                  | VT100, ANSI)",
    "AT[+or-]SNIFF     | Dis/enable sniffer",
    "ATA               | Answer/ANSWER Mode",
    "ATO               | Answer/Originate",
    "ATS0=<0|1>        | AutoAnswer on/off",
    "ATTERMANSI        | Set TERM to ANSI",
    "ATCPM             | Go into CP/M",
    "ATPBLIST          | List Phonebook",
    "ATPBCLEAR         | Clear Phonebook",
    "ATPB<num>=<host>  | Add to Phonebook"
});

void modem_if::handle_help() {
    for (const auto& msg : helpMessages) {
        at_cmd_println(msg);
    }

    at_cmd_println();

    if (listen_port > 0) {
        send_help_message(HELPPORT1, false);
        at_cmd_println(listen_port);
    }
    else {
        send_help_message(HELPPORT4);
    }
    send_response(RESULT_CODE_OK);
}

void modem_if::send_help_message(HelpMessageKey key, bool addEol) {
    if (help_messages.find(key) != help_messages.end()) {
        at_cmd_println(help_messages[key], addEol);
    } else {
        Debug_printf("Error: Message not found for key: %d\n", key);
    }
}

void modem_if::handle_hangup() {
    if (tcp_client->connected() == true) {
        tcp_client->flush();
        tcp_client->stop();
        cmd_mode = true;

        send_response(RESULT_CODE_NO_CARRIER);

        // C++ magic: this will call the TelnetDeleter (i.e. telnet_free()) for us automagically.
        telnet.reset(telnet_init(telopts, telnet_event_handler_fn, 0, this));

        CRX = false;

        if (listen_port > 0) {
            // TODO: these are commented out in the original implementation, why?
            // tcp_server->stop();
            // tcp_server->begin(listenPort);
        }
    }
    else {
        send_response(RESULT_CODE_OK);
    }
}

void modem_if::handle_dial() {
    std::string host, port;
    std::string hostpb;

    int portIndex = cmd.find(':');
    if (portIndex != std::string::npos)
    {
        host = cmd.substr(cmd.size(), portIndex - cmd.size());
        port = cmd.substr(portIndex + 1);
    }
    else
    {
        host = cmd.substr(cmd.size());
        port = "23"; // Telnet default
    }

    util_string_trim(host); // allow spaces or no spaces after AT command

    Debug_printf("DIALING: %s\n", host.c_str());

    // Check if the number is a phonebook entry, and if so if it is in the phonebook
    if (host.find_first_not_of("0123456789") == std::string::npos)
    {
        if (!hostpb.empty())
            hostpb = Config.get_pb_host_name(host.c_str());
        {
            // replace host:port with phonebook information
            port = Config.get_pb_host_port(host.c_str());
            host = hostpb;
        }
    }

    if (host == "5551234") // Fake it for BobTerm
    {
        CRX = true;
        answered = false;
        answer_timer = fnSystem.millis();
        // This is so macros in Bobterm can do the actual connect.
        fnSystem.delay(ANSWER_TIMER_MS);
        at_cmd_println("CONNECT ", false);
        at_cmd_println(modem_baud);
    }
    else
    {
        at_cmd_println("Connecting to ", false);
        at_cmd_println(host, false);
        at_cmd_println(":", false);
        at_cmd_println(port);

        int portInt = std::stoi(port);

        if (tcp_client->connect(host.c_str(), portInt))
        {
            tcp_client->setNoDelay(true); // Try to disable naggle
            answered = false;
            answer_timer = fnSystem.millis();
            cmd_mode = false;
        }
        else
        {
            send_response(RESULT_CODE_NO_CARRIER);
            CRX = false;
            telnet.reset(telnet_init(telopts, telnet_event_handler_fn, 0, this));
        }
    }
}

void modem_if::handle_wifi_list() {
    at_cmd_println();
    send_help_message(HELPSCAN1);

    int n = fnWiFi.scan_networks();

    at_cmd_println();

    if (n == 0)
    {
         send_help_message(HELPSCAN2);
    }
    else
    {
        at_cmd_println(n, false);
        send_help_message(HELPSCAN3);
        at_cmd_println();

        char ssid[32];
        char bssid[18];
        uint8_t rssi;
        uint8_t channel;
        uint8_t encryption;

        for (int i = 0; i < n; ++i)
        {
            // Print SSID and RSSI for each network found
            fnWiFi.get_scan_result(i, ssid, &rssi, &channel, bssid, &encryption);
            at_cmd_println(i + 1, false);
            at_cmd_println(": ", false);
            at_cmd_println(ssid, false);
            at_cmd_println(" [", false);
            at_cmd_println(channel, false);
            at_cmd_println("/", false);
            at_cmd_println(rssi, false);
            at_cmd_println("]");
            at_cmd_println("    ", false);
            at_cmd_println(bssid, false);
            send_help_message(encryption == WIFI_AUTH_OPEN ? HELPSCAN4 : HELPSCAN5);
        }
    }
    at_cmd_println();

    send_response(RESULT_CODE_OK);
}

void modem_if::handle_wifi_connect() {
    std::string ssid, key;

    int keyIndex = cmd.find(',');
    if (keyIndex != std::string::npos)
    {
        ssid = cmd.substr(13, keyIndex - 13 + 1);
        key = cmd.substr(keyIndex + 1);
    }
    else
    {
        ssid = cmd.substr(6);
        key = "";
    }

    send_help_message(HELPWIFICONNECTING, false);
    at_cmd_println(ssid, false);
    at_cmd_println("/", false);
    at_cmd_println(key);

    fnWiFi.connect(ssid.c_str(), key.c_str());

    int retries = 0;
    while ((!fnWiFi.connected()) && retries < 20)
    {
        fnSystem.delay(1000);
        retries++;
        at_cmd_println(".", false);
    }
    if (retries >= 20)
        send_response(RESULT_CODE_ERROR);
    else
        send_response(RESULT_CODE_OK);

}

void modem_if::handle_get() {
    // TODO: Can we do HTTPS too? Would need something to handle the encryption

    // From the URL, aquire required variables
    // (12 = "ATGEThttp://")
    int portIndex = cmd.find(':', 12); // Index where port number might begin
    int pathIndex = cmd.find('/', 12); // Index first host name and possible port ends and path begins
    int port;
    std::string path, host;

    if (pathIndex < 0) {
        pathIndex = cmd.length();
    }
    if (portIndex < 0) {
        port = 80;
        portIndex = pathIndex;
    }
    else {
        port = std::stoi(cmd.substr(portIndex + 1, pathIndex - (portIndex + 1) + 1));
    }

    host = cmd.substr(12, portIndex - 12 + 1);
    path = cmd.substr(pathIndex);
    if (path.empty())
        path = "/";

    // TODO: Can we use the httpclient here instead of raw tcp? This would then handle HTTPS etc.
    // Establish connection
    if (!tcp_client->connect(host.c_str(), port)) {
        send_response(RESULT_CODE_NO_CARRIER);
        telnet.reset(telnet_init(telopts, telnet_event_handler_fn, 0, this));
        CRX = false;
    }
    else {
        // TODO: can we just use RESULT_CODE_CONNECT_XXXX?
        if (use_numeric_result_code) {
            at_connect_resultCode();
        }
        else {
            at_cmd_println("CONNECT ", false);
            at_cmd_println(modem_baud);
        }
        CRX = true;
        cmd_mode = false;

        // Send a HTTP request before continuing the connection as usual
        std::string request = "GET ";
        request += path;
        request += " HTTP/1.1\r\nHost: ";
        request += host;
        request += "\r\nConnection: close\r\n\r\n";
        tcp_client->write(request);
    }

}

void modem_if::handle_port() {
    int port = std::stoi(cmd.substr(6));
    if (port > 65535 || port < 0) {
        send_response(RESULT_CODE_ERROR);
        return;
    }

    if (listen_port != 0) {
        tcp_client->stop();
        tcp_server->stop();
    }

    listen_port = port;
    tcp_server->setMaxClients(1);
    int res = tcp_server->begin(listen_port);
    if (res == 0)
        send_response(RESULT_CODE_ERROR);
    else
        send_response(RESULT_CODE_OK);

}

void modem_if::handle_v0() {
    at_cmd_resultCode(RESULT_CODE_OK);
    use_numeric_result_code = true;
}

void modem_if::handle_v1() {
    at_cmd_println("OK");
    use_numeric_result_code = false;
}

void modem_if::handle_e(bool _command_echo) {
    command_echo = _command_echo;
    send_response(RESULT_CODE_OK);
}

void modem_if::handle_s0(bool _auto_answer) {
    auto_answer = _auto_answer;
    send_response(RESULT_CODE_OK);
}

void modem_if::handle_sniff(bool enable) {
    get_modem_sniffer()->setEnable(enable);
    send_response(RESULT_CODE_OK);
}

void modem_if::handle_term(std::string type) {
    term_type = type;
    send_response(RESULT_CODE_OK);
}

void modem_if::handle_cpm() {
    if (Config.get_cpm_enabled()) {
        modem_active = false;
        // TODO!! How do we get the CPM device?
        // SIO.getCPM()->init_cpm(modemBaud);
        // SIO.getCPM()->cpmActive = true;
    }
    else {
        at_cmd_println("CP/M IS DISABLED");
    }
}

void modem_if::handle_pb_list() {
    at_cmd_println();
    at_cmd_println("Phone#       Host");
    for (int i = 0; i < MAX_PB_SLOTS; ++i)
    {
        // Check if empty
        std::string pbEntry = Config.get_pb_entry(i);
        if (!pbEntry.empty())
            at_cmd_println(pbEntry);
    }
    at_cmd_println();

    send_response(RESULT_CODE_OK);
}

void modem_if::handle_pb_clear() {
    Config.clear_pb();
    send_response(RESULT_CODE_OK);
}

void modem_if::handle_add_entry(const std::string& phnumber, const std::string& rest) {
    if (phnumber.find_first_not_of("0123456789") != std::string::npos) {
        send_response(RESULT_CODE_ERROR);
        return;
    }

    std::string host, port = "23"; // Default port
    int portIndex = rest.find(':');
    if (portIndex != std::string::npos) {
        host = rest.substr(0, portIndex);
        port = rest.substr(portIndex + 1);
    } else {
        host = rest;
    }

    if (Config.add_pb_number(phnumber.c_str(), host.c_str(), port.c_str()))
        send_response(RESULT_CODE_OK);
    else
        send_response(RESULT_CODE_ERROR);
}

void modem_if::handle_delete_entry(const std::string& phnumber) {
    if (Config.del_pb_number(phnumber.c_str()))
        send_response(RESULT_CODE_OK);
    else
        send_response(RESULT_CODE_ERROR);
}

void modem_if::handle_pb() {
    // From the AT command get the info to add. Ex: atpb4321=irata.online:8002
    // or delete ex: atpb4321
    // ("ATPB" length 4)

    int hostIndex = cmd.find('=');
    std::string phnumber = cmd.substr(4, hostIndex != std::string::npos ? hostIndex - 4 : std::string::npos);

    if (hostIndex != std::string::npos) {
        std::string rest = cmd.substr(hostIndex + 1);
        handle_add_entry(phnumber, rest);
    } else {
        handle_delete_entry(phnumber);
    }
}

void modem_if::handle_o() {
    if (tcp_client->connected()) {
        if (use_numeric_result_code) {
            at_cmd_resultCode(modem_baud);
        }
        else {
            at_cmd_println("CONNECT ", false);
            at_cmd_println(modem_baud);
        }
        cmd_mode = false;
    }
    else
        send_response(RESULT_CODE_OK);

}

void modem_if::at_connect_resultCode() {
    static const std::map<int, int> baudToResultCode = {
        {300, 1},
        {1200, 5},
        {2400, 10},
        {4800, 18},
        {9600, 13},
        {19200, 85}
    };

    int resultCode = baudToResultCode.count(modem_baud) ? baudToResultCode.at(modem_baud) : 1;

    get_uart()->print(resultCode);
    get_uart()->write(ASCII_CR);
}

void modem_if::at_cmd_resultCode(int result_code) {
    get_uart()->print(result_code);
    get_uart()->write(ASCII_CR);
    get_uart()->write(ASCII_LF);
}

void modem_if::just_eol() {
    if (was_last_cmd_atascii) {
        get_uart()->write(ATASCII_EOL);
    } else {
        get_uart()->write(ASCII_CR);
        get_uart()->write(ASCII_LF);
    }
}

void modem_if::at_cmd_println() {
    at_cmd_println_common("", true, true);
}

void modem_if::at_cmd_println(const char *s, bool add_eol) {
    at_cmd_println_common(s, add_eol);
}

void modem_if::at_cmd_println(std::string s, bool add_eol) {
    at_cmd_println_common(s, add_eol);
}

void modem_if::at_cmd_println(int i, bool add_eol) {
    at_cmd_println_common(i, add_eol);
}


#endif // USE_NEW_MODEM_IF